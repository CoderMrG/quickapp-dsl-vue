
> 文章分为四个部分：

- 背景介绍
- 实现方案
- 联系交流


## 背景介绍

大家好，这里是快应用团队，经过一段时间的技术积累，今天主要分享一篇文章：让快应用支持第三方DSL的开发能力；

简单来说，就是开发者可以使用自己喜欢的DSL来进行快应用项目的开发；本次快应用的1050版本增加对Vue DSL的内测支持，同时我们也将开放一系列的API，其它DSL同时可以引入进来；

### 过往回溯

自从微信小程序从16年10月内测以来，前端开发在端适配上迎来了巨大的变化；开发者写的代码，不仅要满足WEB平台、原生渲染，而且还要增加对小程序的支持；

18年3月成立了快应用联盟，随后又涌现了百度/阿里/头条多个小程序生态，给开发者提出更高要求，从"面向模块的开发"到"面向多端适配"；

可喜的是：市场上逐渐衍生出新的前端框架，就是希望能够提供统一的DSL，让开发者完成一套代码，多端自适应的运行效果；

面对市场上众多的框架，新手开发者如何粗略了解与选择呢?

### 当前现状

站在发展过程的角度上，当前市场上的DSL框架主要分为以下4类：

- WEB型：
 介绍：主要只用于浏览器的页面开发，因为语法简单、容易上手、设计清晰而备受开发者的喜欢；
 比如：React、Vue、Angular 等轻量级的数据驱动框架；
 发展：因为广泛的用户基础，逐渐流行多种面向PC/移动端的UI组件库，如：Ant Design、Element UI；
 职责：提供开发者钟爱的语法，解决前端项目中架构、工程、数据流等问题；

- 平台型
 介绍：满足初期自身平台的渲染能力；
 比如：Weex初期的we文件，微信小程序的wxml语法，快应用提供的ux文件、Flutter的dart语言；
 发展：特有的语法，开发者略显水土不服，同时重新开发一套代码，学习成本较大；
 职责：满足初版与迭代，服务于平台的系统能力提供；向技术深度的重新渲染下沉；
 
- 适配型
 介绍：介于平台型初期DSL不适应，引入开发者喜欢的WEB型语法；
 比如：Weex上支持Vue语法，微信小程序开发中的Wepy/mpvue，以及本次介绍的快应用引入Vue开发方式；
 发展：这里差异比较大，有的是通过DSL爱好者移植适配完成的，经历二次编译（WEB型DSL先转成平台型DSL，再经历平台编译时转换）；有的是平台自身开发支持的；
 二次编译的优势在于，它不需要了解平台内部是如何实现的，仅需要根据官方提供的能力进行能力适配即可；缺点在于：比较依赖平台型DSL能力，如果不支持则适配困难，同时运行时可能存在二次转换才能完成对UI的操作；
 如果是平台自身支持的，那么开发者代码，直接就可以完成对UI的操作，减少中间步骤，加速渲染；
 毫无疑问，平台自身的支持，能够比二次转换，带来更好的效果；
 职责：完成开发者从WEB到某个平台的平滑过渡；
 
- 全能型
 介绍：该类型源于适配型，更多解决多端适配问题；同时抽象APP容器管理，能力调用等概念，完成适配；
 比如：滴滴的chameleon、去哪儿的nanachi、京东的taro
 发展：尽量抹平WEB渲染与原生渲染的差异，抽象应用模型，完成页面渲染与功能管理，最后适配到各平台；当然适配时如果直接完成对平台API的操作，要比二次转换效果要好的多；
 职责：完成多端适配，做到一套代码多端适配的效果；

那么本文讲述的快应用引入Vue DSL，属于上述的适配型，让平台自身支持，为往后出现的高效全能型框架服务；

### 近期趋势

在作者看来，新的19年，全能型框架可能逐渐取代适配型，并且从设计、规范、架构等角度上，产生新的理念与原则；基于此，各平台通过自身或者开源爱好者完成适配；

当然，对于各平台（小程序、快应用）也会加深对统一的认识，借助于W3C研讨会、兴趣组、前端会议，促教交流，考虑抽象出自己的渲染API与能力通道，让更友好的全能型框架完成高效适配；

另外，中间也肯定会产生一些兼容性类库，完成polyfill的辅助角色；

所以基于这种观点，快应用采用了这样的路线：开放页面渲染API，轻松支持第三方的DSL；那么快应用本次支持Vue的DSL，都做了哪些事情呢？

## 实现方案

如果梳理一下浏览器与快应用的页面渲染流程，主体过程是这样的：

步骤1. 语言运行时执行开发者的业务代码；
步骤2. 基于DSL的业务，生成MVVM的模型；
步骤3. 业务中对数据的操作，触发对DOM节点的更新；
步骤4. DOM更新后渲染引擎，发出VSync申请，标记脏值节点；
步骤5. 遍历待更新节点，逐个完成样式计算、布局计算、绘制合成，完成渲染；

当前实现两者的区别主要在于：线程的工作分配与配合机制、渲染实现的具体逻辑；

对于DSL开发者来说，是不需要关注深度实现的，因为快应用自身会构建一套页面UI的DOM树，因此抽象出了一套DOM的API，提供给DSL；

所以，DSL开发者只需要使用快应用提供的节点操作API，即可轻易完成适配；

为了方便理解，我们增加了TodoMVC的示例项目[quickappcn/todomvc-vue](https://github.com/quickappcn/todomvc-vue)；

实际效果如下：

![效果预览](https://github.com/quickappcn/todomvc-vue/raw/master/preview.gif)

### 整体设计

以当前支持Vue的适配为例，主要工作在于：编译时、运行时两方面；

#### 编译时

提供对DSL的项目脚手架、与DSL使用快应用组件与样式的校验解析能力；

关于项目打包、分包、调试等非DSL专有能力的，均已模块独立；

当前整个快应用项目的开发，使用的是[官方hap-toolkit工具](https://www.npmjs.com/package/hap-toolkit)，这是一个基于NodeJS的npm类库；

项目结构采用模块化的开发方式，借助于[lerna](https://lernajs.io/)完成耦合分离；

DSL开发者只需要对应的DSL模块，完成增加模板化、语法解析器，即可完成开发；

同时为了保证稳定性，也可以增加测试用例，完成单元测试与项目测试的功能；测试框架当前实现使用了[Facebook的Jest](https://jestjs.io/)

hap-toolkit@0.3.0版本上增加了对Vue DSL的支持，不过并未采用`lerna`管理，后续发布的 0.4 版本以后会用这种方式；

#### 运行时

执行开发者的业务代码，管理DSL中的驱动模型，完成数据更新到DOM操作的转换；

快应用运行时会在底层提供DOM的API，针对每个页面提供一个`document`节点；

DSL层除了包含官方Vue的代码之外，还有两部分：

1. DOM API调用：完成对节点的操作；
2. 容器适配模块：提供针对应用、页面概念的适配，因为快用用是一个多页面运行平台；

针对这块，快应用在Github提供了以下几个项目：

- [quickappcn/Vue](https://github.com/quickappcn/vue)

从官方Vue站点克隆一份，保存Vue核心源码、以及针对快应用DOM API的适配；

- [quickappcn/quickapp-dsl-vue](https://github.com/quickappcn/quickapp-dsl-vue)

新创建的项目，里面保存了：DSL在快应用平台上的应用容器适配，如：生命周期、事件通知等；

快应用运行平台对Vue DSL的支持，是从1050版本开始内测，预计1060版本使用正式版本发布；

## 开发体验

对于实际开发快应用产品的开发者（简称：产品开发者）来说，如果在快应用平台上，进行Vue的开发呢？

其实开发过程，与快应用标准的DSL项目(标准DSL以ux作为后缀名)开发方式一致：

步骤1：全局安装npm类库：`npm install -g hap-toolkit`
步骤2：用脚手架初始化项目：`hap init --vue`
步骤3：构建项目：`npm run build`
步骤4：运行在快应用的APK平台，开发者可以选择本地安装或者在线更新的方式，与标准开发方式一致；

### 项目代码

总结一下，本次快应用引入Vue DSL而提供的项目：

- [quickappcn/todomvc-vue](https://github.com/quickappcn/todomvc-vue)

描述：作为快应用的项目，展示Vue在平台上运行的实际示例效果；

- [quickappcn/Vue](https://github.com/quickappcn/vue)

描述：从官方Vue站点克隆而来，提供针对快应用DOM API的适配；

- [quickappcn/quickapp-dsl-vue](https://github.com/quickappcn/quickapp-dsl-vue)

描述：提供了DSL在平台上的应用容器适配，如：生命周期、事件通知等；同时包含针对上一个项目的构建后代码；

为了辅助开发，开发者可以补充测试用例，执行：`test:suite:framework`会完成针对：单元测试、项目测试的功能保证；

其中的单元测试：测试Vue的自身功能表现正常；

其中的项目测试：测试Vue在基于NodeJS的快应用模拟平台上，是否表现正常；

- [hap-toolkit](https://github.com/quickappcn/hap-toolkit)

描述：提供对开发者写的DSL的语法校验、项目打包等功能；


### 加载过程

在快应用平台中，DSL是如何加载并完成渲染的呢？大家看下下面的图例就明白了；

![加载过程](./dsl-res/loading-process.png)

快应用的运行可以分为三个阶段：

- 第一阶段：环境准备

平台启动，暴露DOM等相关API，加载DSL代码，并完成与平台的桥接通讯；

- 第二阶段：业务代码执行

加载并执行开发者项目中的 vue 业务代码（编译后转换为JS），建立驱动模型，完成VDOM的对比；

- 第三阶段：平台渲染

上一层VDOM对比的结果，转换成对平台的DOM API的实际调用，平台线程然后做布局计算、绘制等完成界面的展示；


### 平台解耦

上图所示，可以看出：DSL与平台的解耦与交互发生在第一阶段；

那么双方需要考虑哪些方面的解耦事项呢？主要分为以下几个部分：

- 容器管理

快应用是一个应用形态，包含多个页面，这点不同于浏览器，所以就会存在应用的生命周期；

开发者需要监听这些生命周期，用于完成：数据请求、统计、性能监控；

为了保持解耦合，平台使用了 Publish/Subscribe 模型，DSL只需要订阅相关的事件，即可暴露给开发者；

开发者可以从 `项目quickappcn/quickapp-dsl-vue`的 `src/shared文件夹` 中得到提示；

- 页面渲染

对于每个页面来说，页面的渲染依赖于组件树的构建，为了方便对组件进行操作，平台提供了一套类似浏览器的组件操作接口，称为平台DOM；

那么这些接口也就称为：平台DOM API，同时为了提升DSL适配的简易性，快应用的DOM与浏览器中的DOM非常相似；

比如：创建节点的API（`document.createElement`）、节点增删的API（`element.appendChild()、element.insertBefore()`）

开发者可以从 `项目quicappcn/vue`的`src/platforms/quickapp/node-ops.js文件`中得到提示；

- 接口功能

业务开发中，开发者肯定需要调用系统功能，如：fetch请求：`require('@sysem.fetch'')`、地理位置：`require('@system.geolocation')`

这方面的语法与平台的标准DSL语法保持一致，会在编译时进行转换，如：fetch请求转换为：`$app_require$("@app-module/system.fetch")$`；

平台执行开发者的JS代码时，会自动注入一个全局函数`$app_require$`；那么JS执行时就会通过该函数完成系统功能的获取；

开发者可以从 `项目quickappcn/quickapp-dsl-vue`的 `src/dsls/vue/page/interface.js文件` 中得到提示；


### 测试保证

> 提供NodeJS平台的环境模拟

对于DSL开发者来说，如果每次对源码修改后，都需要在手机设备上测试运行，确认功能的话，将会及其浪费时间；

为了解决这一难题，快应用平台的前端层面，提供了在NodeJS环境上的平台模拟能力；因此开发者可以完成两方面的测试保证：

- 单元测试

对DSL的基本功能进行测试，如：指令、数据驱动等各种DSL特性；

相关代码请参考：`项目quickappcn/quickapp-dsl-vue`的 `test/suite/dsls/vue/unit文件夹`

测试命令请参考：`项目quickappcn/quickapp-dsl-vue`的 `package.json中的"test:suite:framework:main:vue:unit"命令`

- 项目测试

开发者像开发正式的快应用项目一样，开发页面；模拟平台会将测试项目编译打包，然后逐个执行开发者的页面代码；

开发者可以在这里，测试DOM树的结构一致性、生命周期、接口功能等；

相关代码请参考：`项目quickappcn/quickapp-dsl-vue`的 `test/suite/dsls/vue/project文件夹`

测试命令请参考：`项目quickappcn/quickapp-dsl-vue`的 `package.json中的"test:suite:framework:main"命令`


### 信息提示

截止本文发布时，快应用联盟的运行平台最新版本是：1040，编译工具hap-toolkit最新版本是0.3；

我们将在1050的版本（不久后发布）上，提供对Vue DSL的内测能力；与之匹配的工具版本需要在0.3之上；

最终计划在1060版本中，携带正式版本的Vue DSL；

在正式支持版本发布之前，工具会不会更新版本，仅支持最新版本的编译工具；敬请谅解！


### 联系交流

> 对实现方式感兴趣

